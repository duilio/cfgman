{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CfgMan \u00b6 A configuration manager for Python application.","title":"Home"},{"location":"#cfgman","text":"A configuration manager for Python application.","title":"CfgMan"},{"location":"contributing/","text":"How to contribute \u00b6 TBD. Deploy a new release \u00b6 Prepare a new branch. Bump version: $ poetry version patch We do follow semver, so use the appropriate string instead of patch to increment the version (e.g. minor , major , prerelease ) Push the new branch and open a PR. Once merged, create a new tag: $ git tag x.y.z && git push --tags Edit the new release created by Github TODO: Add CHANGELOG ? We might automate the tag creation once the a new version land in the main branch.","title":"How to contribute"},{"location":"contributing/#how-to-contribute","text":"TBD.","title":"How to contribute"},{"location":"contributing/#deploy-a-new-release","text":"Prepare a new branch. Bump version: $ poetry version patch We do follow semver, so use the appropriate string instead of patch to increment the version (e.g. minor , major , prerelease ) Push the new branch and open a PR. Once merged, create a new tag: $ git tag x.y.z && git push --tags Edit the new release created by Github TODO: Add CHANGELOG ? We might automate the tag creation once the a new version land in the main branch.","title":"Deploy a new release"},{"location":"usage/","text":"Usage \u00b6 TBD.","title":"Usage"},{"location":"usage/#usage","text":"TBD.","title":"Usage"},{"location":"api/cfgman/","text":"cfgman is a configuration manager for python. It provides some utility to: combine configuration from different sources (e.g. files, environment variables, ...) validate the configuration (via apischema) configclass ( cls ) \u00b6 Register the class as a config class. If the class is not already a dataclass , apply the dataclass decorator too. Parameters: Name Type Description Default cls type [ _T ] class to register. required Returns: Type Description type [ _T ] Either cls or dataclass(cls) . Examples: Define a new configclass. >>> @configclass ... class A : ... x : int get_default_config ( cls ) \u00b6 Return the default configuration for the given configclass . Default config instances are created once load_config has been called successfully. Note If a class has been instantiated multiple times (because load_config has been called multiple times or because it has multiple places in the configuration) the last instance is considered the default one. Parameters: Name Type Description Default cls type [ _T ] the requested type of the default instance. required Raises: Type Description KeyError if the class is not registered via configclass . Returns: Type Description _T The default instance for cls . load_config ( cls , * sources ) \u00b6 Load a configuration from multiple sources. The order of the sources matters: the first one is the lowest priority one (e.g. default values), the last one is the highest priority one (e.g. command line parameters). Default instances of the configclasses in the result tree will be assigned if the configuration is loaded correctly. Parameters: Name Type Description Default cls type [ _T ] configuration class to use for both validation and deserialization. required *sources dict [ str , Any ] | Callable [[ type [ _T ]], dict [ str , Any ] | list [ dict [ str , Any ]]] configuration sources. A source can be a regular dict or a loader . () Returns: Type Description _T An instance of the configclass with the data resulting from the merged sources. reset () \u00b6 Reset the default configclasses. Warning : this is an utility function for tests, you hardly need to use this in your app.","title":"cfgman"},{"location":"api/cfgman/#cfgman.configclass","text":"Register the class as a config class. If the class is not already a dataclass , apply the dataclass decorator too. Parameters: Name Type Description Default cls type [ _T ] class to register. required Returns: Type Description type [ _T ] Either cls or dataclass(cls) . Examples: Define a new configclass. >>> @configclass ... class A : ... x : int","title":"configclass()"},{"location":"api/cfgman/#cfgman.get_default_config","text":"Return the default configuration for the given configclass . Default config instances are created once load_config has been called successfully. Note If a class has been instantiated multiple times (because load_config has been called multiple times or because it has multiple places in the configuration) the last instance is considered the default one. Parameters: Name Type Description Default cls type [ _T ] the requested type of the default instance. required Raises: Type Description KeyError if the class is not registered via configclass . Returns: Type Description _T The default instance for cls .","title":"get_default_config()"},{"location":"api/cfgman/#cfgman.load_config","text":"Load a configuration from multiple sources. The order of the sources matters: the first one is the lowest priority one (e.g. default values), the last one is the highest priority one (e.g. command line parameters). Default instances of the configclasses in the result tree will be assigned if the configuration is loaded correctly. Parameters: Name Type Description Default cls type [ _T ] configuration class to use for both validation and deserialization. required *sources dict [ str , Any ] | Callable [[ type [ _T ]], dict [ str , Any ] | list [ dict [ str , Any ]]] configuration sources. A source can be a regular dict or a loader . () Returns: Type Description _T An instance of the configclass with the data resulting from the merged sources.","title":"load_config()"},{"location":"api/cfgman/#cfgman.reset","text":"Reset the default configclasses. Warning : this is an utility function for tests, you hardly need to use this in your app.","title":"reset()"},{"location":"api/loaders/","text":"Loaders retrieve data from sources such as files and environment variables and create a tree to be used by load_config . A loader is just a function that takes parameter and return a dictionary. A loader factory is a wrapper over a loader which accepts only one parameter: a configclass used for the result validation. load_config normally treats all callables as function loader of this kind and pass them the configclass of the configuration we are loading. subpath \u00b6 In some situations you might want to validate only a subset of a configuration, in these cases the subpath argument of the loader may be handy. @configclass class ServerConfig : host : str port : int @configclass class ApplicationConfig : name : str = \"spam\" server : ServerConfig config = load_config ( ApplicationConfig , file_loader ( cls = ServerConfig , subpath = \"server\" , files = [ \"~/.spam.json\" ]) ) The result loaded by file path will be first validated against the cls schema and then wrapped in a tree at the given subpath. Note We are passing the cls parameter, otherwise the validation would be performed against the ApplicationConfig schema before the wrapping. Not what we want! env_loader ( * , cls = None , subpath = None , mapping , validate = False , prefix = '' , env = None ) \u00b6 Create a new loader for environment variables. Accept the same parameters of load_env but return a callable instead. Parameters: Name Type Description Default cls type [ _T ] | None class to use for validation. None mapping Mapping [ str , str ] the variable mapping. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . None validate bool validate the result against the cls . False prefix str prefix to apply to all keys in the mapping. '' env Mapping [ str , str ] | None dict to use instead of the environment variables. If None use os.environ . None Returns: Type Description Callable [[ type ], dict [ str , Any ]] A function that can be used as a source for the configuration. See load_config . file_loader ( * , cls = None , subpath = None , files , supported_file_types = None , validate = True , load_all_files = False , load_at_least_one_file = False ) \u00b6 Return a new loader to be used by load_config . This is just a wrapper for load_file . Parameters: Name Type Description Default cls type | None class used for validation. None files Iterable [ str | Path ] | str | Path either a file path or a list of file paths. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . Validation is done before wrapping. None supported_file_types Sequence [ FileType ] | None list of supported file types. None means all of them. None validate bool validate the result. True load_all_files bool if False unexisting files are skipped. False load_at_least_one_file bool if True an exception is raised when no files are loaded. False Returns: Type Description Callable [[ type ], list [ dict [ str , Any ]]] A function that can be used as a source for the configuration. See load_config . load_env ( cls = None , * , mapping , subpath = None , validate = False , prefix = '' , env = None ) \u00b6 Load a dict from environment variables. Given a mapping envvar -> dotted.path , creates a dict where each dotted.path contains the variable of the envvar . Missing variables are ignored. Examples: >>> load_env ( ... mapping = { \"VAR1\" : \"a.b\" , \"VAR2\" : \"a.c\" , \"MISS\" : \"b.c\" }, ... env = { \"VAR1\" : \"var1\" , \"VAR2\" : \"var2\" } ... ) {'a': {'b': 'var1', 'c': 'var2'}} Parameters: Name Type Description Default cls type [ _T ] | None class to use for validation. None mapping Mapping [ str , str ] the variable mapping. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . None validate bool validate the result against the cls . False prefix str prefix to apply to all keys in the mapping. '' env Mapping [ str , str ] | None dict to use instead of the environment variables. If None use os.environ . None Returns: Type Description dict [ str , Any ] A dict that can be used as a source for the configuration. See load_config . load_file ( cls , * , files , subpath = None , supported_file_types = None , validate = True , load_all_files = False , load_at_least_one_file = False ) \u00b6 Load a config file or multiple config files. Parameters: Name Type Description Default cls type [ _T ] class used for validation. required files Iterable [ str | Path ] | str | Path either a file path or a list of file paths. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . Validation is done before wrapping. None supported_file_types Sequence [ FileType ] | None list of supported file types. None means all of them. None validate bool validate the result. True load_all_files bool if False unexisting files are skipped. False load_at_least_one_file bool if True an exception is raised when no files are loaded. False Returns: Type Description list [ dict [ str , Any ]] A list of dictionary to be used as a source for list [ dict [ str , Any ]] load_config . env \u00b6 Environment variable loaders. env_loader ( * , cls = None , subpath = None , mapping , validate = False , prefix = '' , env = None ) \u00b6 Create a new loader for environment variables. Accept the same parameters of load_env but return a callable instead. Parameters: Name Type Description Default cls type [ _T ] | None class to use for validation. None mapping Mapping [ str , str ] the variable mapping. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . None validate bool validate the result against the cls . False prefix str prefix to apply to all keys in the mapping. '' env Mapping [ str , str ] | None dict to use instead of the environment variables. If None use os.environ . None Returns: Type Description Callable [[ type ], dict [ str , Any ]] A function that can be used as a source for the configuration. See load_config . load_env ( cls = None , * , mapping , subpath = None , validate = False , prefix = '' , env = None ) \u00b6 Load a dict from environment variables. Given a mapping envvar -> dotted.path , creates a dict where each dotted.path contains the variable of the envvar . Missing variables are ignored. Examples: >>> load_env ( ... mapping = { \"VAR1\" : \"a.b\" , \"VAR2\" : \"a.c\" , \"MISS\" : \"b.c\" }, ... env = { \"VAR1\" : \"var1\" , \"VAR2\" : \"var2\" } ... ) {'a': {'b': 'var1', 'c': 'var2'}} Parameters: Name Type Description Default cls type [ _T ] | None class to use for validation. None mapping Mapping [ str , str ] the variable mapping. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . None validate bool validate the result against the cls . False prefix str prefix to apply to all keys in the mapping. '' env Mapping [ str , str ] | None dict to use instead of the environment variables. If None use os.environ . None Returns: Type Description dict [ str , Any ] A dict that can be used as a source for the configuration. See load_config . file \u00b6 File loaders. Support multiple file formats and multiple files. (e.g. default config + user overrides) file_loader ( * , cls = None , subpath = None , files , supported_file_types = None , validate = True , load_all_files = False , load_at_least_one_file = False ) \u00b6 Return a new loader to be used by load_config . This is just a wrapper for load_file . Parameters: Name Type Description Default cls type | None class used for validation. None files Iterable [ str | Path ] | str | Path either a file path or a list of file paths. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . Validation is done before wrapping. None supported_file_types Sequence [ FileType ] | None list of supported file types. None means all of them. None validate bool validate the result. True load_all_files bool if False unexisting files are skipped. False load_at_least_one_file bool if True an exception is raised when no files are loaded. False Returns: Type Description Callable [[ type ], list [ dict [ str , Any ]]] A function that can be used as a source for the configuration. See load_config . load_file ( cls , * , files , subpath = None , supported_file_types = None , validate = True , load_all_files = False , load_at_least_one_file = False ) \u00b6 Load a config file or multiple config files. Parameters: Name Type Description Default cls type [ _T ] class used for validation. required files Iterable [ str | Path ] | str | Path either a file path or a list of file paths. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . Validation is done before wrapping. None supported_file_types Sequence [ FileType ] | None list of supported file types. None means all of them. None validate bool validate the result. True load_all_files bool if False unexisting files are skipped. False load_at_least_one_file bool if True an exception is raised when no files are loaded. False Returns: Type Description list [ dict [ str , Any ]] A list of dictionary to be used as a source for list [ dict [ str , Any ]] load_config .","title":"loaders"},{"location":"api/loaders/#cfgman.loaders--subpath","text":"In some situations you might want to validate only a subset of a configuration, in these cases the subpath argument of the loader may be handy. @configclass class ServerConfig : host : str port : int @configclass class ApplicationConfig : name : str = \"spam\" server : ServerConfig config = load_config ( ApplicationConfig , file_loader ( cls = ServerConfig , subpath = \"server\" , files = [ \"~/.spam.json\" ]) ) The result loaded by file path will be first validated against the cls schema and then wrapped in a tree at the given subpath. Note We are passing the cls parameter, otherwise the validation would be performed against the ApplicationConfig schema before the wrapping. Not what we want!","title":"subpath"},{"location":"api/loaders/#cfgman.loaders.env_loader","text":"Create a new loader for environment variables. Accept the same parameters of load_env but return a callable instead. Parameters: Name Type Description Default cls type [ _T ] | None class to use for validation. None mapping Mapping [ str , str ] the variable mapping. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . None validate bool validate the result against the cls . False prefix str prefix to apply to all keys in the mapping. '' env Mapping [ str , str ] | None dict to use instead of the environment variables. If None use os.environ . None Returns: Type Description Callable [[ type ], dict [ str , Any ]] A function that can be used as a source for the configuration. See load_config .","title":"env_loader()"},{"location":"api/loaders/#cfgman.loaders.file_loader","text":"Return a new loader to be used by load_config . This is just a wrapper for load_file . Parameters: Name Type Description Default cls type | None class used for validation. None files Iterable [ str | Path ] | str | Path either a file path or a list of file paths. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . Validation is done before wrapping. None supported_file_types Sequence [ FileType ] | None list of supported file types. None means all of them. None validate bool validate the result. True load_all_files bool if False unexisting files are skipped. False load_at_least_one_file bool if True an exception is raised when no files are loaded. False Returns: Type Description Callable [[ type ], list [ dict [ str , Any ]]] A function that can be used as a source for the configuration. See load_config .","title":"file_loader()"},{"location":"api/loaders/#cfgman.loaders.load_env","text":"Load a dict from environment variables. Given a mapping envvar -> dotted.path , creates a dict where each dotted.path contains the variable of the envvar . Missing variables are ignored. Examples: >>> load_env ( ... mapping = { \"VAR1\" : \"a.b\" , \"VAR2\" : \"a.c\" , \"MISS\" : \"b.c\" }, ... env = { \"VAR1\" : \"var1\" , \"VAR2\" : \"var2\" } ... ) {'a': {'b': 'var1', 'c': 'var2'}} Parameters: Name Type Description Default cls type [ _T ] | None class to use for validation. None mapping Mapping [ str , str ] the variable mapping. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . None validate bool validate the result against the cls . False prefix str prefix to apply to all keys in the mapping. '' env Mapping [ str , str ] | None dict to use instead of the environment variables. If None use os.environ . None Returns: Type Description dict [ str , Any ] A dict that can be used as a source for the configuration. See load_config .","title":"load_env()"},{"location":"api/loaders/#cfgman.loaders.load_file","text":"Load a config file or multiple config files. Parameters: Name Type Description Default cls type [ _T ] class used for validation. required files Iterable [ str | Path ] | str | Path either a file path or a list of file paths. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . Validation is done before wrapping. None supported_file_types Sequence [ FileType ] | None list of supported file types. None means all of them. None validate bool validate the result. True load_all_files bool if False unexisting files are skipped. False load_at_least_one_file bool if True an exception is raised when no files are loaded. False Returns: Type Description list [ dict [ str , Any ]] A list of dictionary to be used as a source for list [ dict [ str , Any ]] load_config .","title":"load_file()"},{"location":"api/loaders/#cfgman.loaders.env","text":"Environment variable loaders.","title":"env"},{"location":"api/loaders/#cfgman.loaders.env.env_loader","text":"Create a new loader for environment variables. Accept the same parameters of load_env but return a callable instead. Parameters: Name Type Description Default cls type [ _T ] | None class to use for validation. None mapping Mapping [ str , str ] the variable mapping. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . None validate bool validate the result against the cls . False prefix str prefix to apply to all keys in the mapping. '' env Mapping [ str , str ] | None dict to use instead of the environment variables. If None use os.environ . None Returns: Type Description Callable [[ type ], dict [ str , Any ]] A function that can be used as a source for the configuration. See load_config .","title":"env_loader()"},{"location":"api/loaders/#cfgman.loaders.env.load_env","text":"Load a dict from environment variables. Given a mapping envvar -> dotted.path , creates a dict where each dotted.path contains the variable of the envvar . Missing variables are ignored. Examples: >>> load_env ( ... mapping = { \"VAR1\" : \"a.b\" , \"VAR2\" : \"a.c\" , \"MISS\" : \"b.c\" }, ... env = { \"VAR1\" : \"var1\" , \"VAR2\" : \"var2\" } ... ) {'a': {'b': 'var1', 'c': 'var2'}} Parameters: Name Type Description Default cls type [ _T ] | None class to use for validation. None mapping Mapping [ str , str ] the variable mapping. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . None validate bool validate the result against the cls . False prefix str prefix to apply to all keys in the mapping. '' env Mapping [ str , str ] | None dict to use instead of the environment variables. If None use os.environ . None Returns: Type Description dict [ str , Any ] A dict that can be used as a source for the configuration. See load_config .","title":"load_env()"},{"location":"api/loaders/#cfgman.loaders.file","text":"File loaders. Support multiple file formats and multiple files. (e.g. default config + user overrides)","title":"file"},{"location":"api/loaders/#cfgman.loaders.file.file_loader","text":"Return a new loader to be used by load_config . This is just a wrapper for load_file . Parameters: Name Type Description Default cls type | None class used for validation. None files Iterable [ str | Path ] | str | Path either a file path or a list of file paths. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . Validation is done before wrapping. None supported_file_types Sequence [ FileType ] | None list of supported file types. None means all of them. None validate bool validate the result. True load_all_files bool if False unexisting files are skipped. False load_at_least_one_file bool if True an exception is raised when no files are loaded. False Returns: Type Description Callable [[ type ], list [ dict [ str , Any ]]] A function that can be used as a source for the configuration. See load_config .","title":"file_loader()"},{"location":"api/loaders/#cfgman.loaders.file.load_file","text":"Load a config file or multiple config files. Parameters: Name Type Description Default cls type [ _T ] class used for validation. required files Iterable [ str | Path ] | str | Path either a file path or a list of file paths. required subpath str | Sequence [ str ] | None wrap the result in the subpath of a new dict . Validation is done before wrapping. None supported_file_types Sequence [ FileType ] | None list of supported file types. None means all of them. None validate bool validate the result. True load_all_files bool if False unexisting files are skipped. False load_at_least_one_file bool if True an exception is raised when no files are loaded. False Returns: Type Description list [ dict [ str , Any ]] A list of dictionary to be used as a source for list [ dict [ str , Any ]] load_config .","title":"load_file()"}]}